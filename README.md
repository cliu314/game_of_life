6.170 Project 1: Phase 2
Clare Liu

Instructions:
To view the simulation, open game_of_life.html. My implementation allows you to start and pause the simulation and click and drag the mouse on cells to select the initial conditions. Clicking on a live cell again makes the cell dead. I also added a button that lets you step through the simulation 1 step at a time and a slider that lets you control the speed of the animation. There are also several buttons to select a pattern, fill the grid randomly with live cells, and clear the grid. My JavaScript code is in game_of_life.js. My QUnit tests are located in the qunit-example directory. Go to test_proj1.html to view the results of the tests . The actual tests are located in tests_proj1.js

Grading Directions:
- Highlights: I used the each functional (line 44 https://github.com/6170-fa14/clareliu_proj1/blob/master/game_of_life.js#L44), which takes a function to run on each cell in the grid. The use of this functional prevents the repetition of nested for loops to access each element in the grid. 
I wanted to use a global variable for the interval time for steps and to keep track of whether the mouse was currently being dragged. Instead, I put all of my code relating to the DOM within a function to keep these variables private. (line 273,275 https://github.com/6170-fa14/clareliu_proj1/blob/master/game_of_life.js#L273)
- Help wanted: I think my getNeighbors function within getAllNeighbors() could be implemented in a  simpler and more efficient way because I am using nested for loops, so I have to make sure the array indices don't go out of bounds. I also have to subtract 1 from the number of neighbors if the original cell is live because then it is counted as a neighbor.
I think I could have done a better job of separating the internal representation of the grid from the display because I had to make more functions public to be able to simultaneously update the internal state and the display.

Design Challenges:
- Grid representation:  The main design challenge was how to represent the grid. One option was to use a 2d array to store the state of all the cells, where 1 represents a live cell and 0 represents a dead cell. One advantage of this option is that it is very easy to access the state of a particular cell by just looking up the element in the array. However, this would require copying of the array or creating a new array when updating the cells for the next generation. The live cells for the next generation need to be determined before the grid is actually updated, so that the number of live neighbors for each cell isn't affected when a previous cell is updated.

Another option was to create a Cell class that keeps track of whether each cell is dead or live and the number of live neighbors it has. I created a 2d array that holds size x size cell objects.  Using this approach allows us to first go through the array and update the number of live neighbors each cell has. We can then go through the array again to update the live/dead attribute because the neighbors were already calculated, so future calculations in the generation can't be affected. I decided to use this approach because even though we have to go through the array of cells twice, no copies of the array need to be made. The code is also more understandable to others and allows more flexibility in adding more attributes for different versions of the game in the future if we have an array of cell objects instead of an array of 1's and 0's.

- DOM Representation: To incorporate the DOM, I represented each cell as a div. If n is the number of cells in a side of the grid, I had a main div with n divs for rows with n divs each for cells (line 280 https://github.com/6170-fa14/clareliu_proj1/blob/master/game_of_life.js#L280). This makes it easy to update the display at the same time the internal grid representation is updated because if cell (x,y) is updated, we can get the x-th child of the main div for the row and then the y-th child of the row. Each div has the class "cell". By default, the cell class has a white background to represent dead cells. When the grid is updated, I add or remove the "live" class from the div to change the display.

